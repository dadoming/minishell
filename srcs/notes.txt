https://www.megaemoji.com/generators/tarty/

▒█▀▄▀█ ▀█▀ ▒█▄░▒█ ▀█▀ ▒█▀▀▀█ ▒█░▒█ ▒█▀▀▀ ▒█░░░ ▒█░░░ 
▒█▒█▒█ ▒█░ ▒█▒█▒█ ▒█░ ░▀▀▀▄▄ ▒█▀▀█ ▒█▀▀▀ ▒█░░░ ▒█░░░ 
▒█░░▒█ ▄█▄ ▒█░░▀█ ▄█▄ ▒█▄▄▄█ ▒█░▒█ ▒█▄▄▄ ▒█▄▄█ ▒█▄▄█ 


Manual POSIX: < https://pubs.opengroup.org/onlinepubs/9699919799/ >

Tree Guide: < https://dev.to/oyagci/generating-a-parse-tree-from-a-shell-grammar-f1 >

Front-End Parser Visualizer: < https://vorpaljs.github.io/bash-parser-playground/ >

Bash Manual: < https://www.gnu.org/software/bash/manual/bash.html >

Readline Manual: < https://tiswww.case.edu/php/chet/readline/readline.html#Programming-with-GNU-Readline >


▒█▀▀█ ▒█▀▀▀ ░█▀▀█ ▒█▀▀▄ ▒█░░░ ▀█▀ ▒█▄░▒█ ▒█▀▀▀ 
▒█▄▄▀ ▒█▀▀▀ ▒█▄▄█ ▒█░▒█ ▒█░░░ ▒█░ ▒█▒█▒█ ▒█▀▀▀ 
▒█░▒█ ▒█▄▄▄ ▒█░▒█ ▒█▄▄▀ ▒█▄▄█ ▄█▄ ▒█░░▀█ ▒█▄▄▄ 

< https://tiswww.case.edu/php/chet/readline/readline.html#Programming-with-GNU-Readline >

Notice how C-f moves forward a character,
while M-f moves forward a word. It is a loose 
convention that control keystrokes operate on 
characters while meta keystrokes operate on words.

Movement commands:
Ctrl-a : move back to start of line
Ctrl-b : move back one character 
Alt-b  : move back a word
Ctrl-e : move forward to end of line
Ctrl-f : move forward one character
Alt-f  : move forward a word

Deletion:
Ctrl-l : clear screen and print current line at top
Ctrl-d : erase current character 
Ctrl-h : erase back one character
Alt-r  : erase current line

Kill and Yank:
Ctrl-k : kill the text from the current position
            the end of the line
Alt-d  : kill from cursor to the end of current word,
            or if between words, to the end of the next
            word
Ctrl-w : kill from the cursor to the previous whitespace
Ctrl-y : yank the most recently killed text into cursor position
Alt-y  : rotate kill-ring, and yank the new top. only
            possible if previous command was Ctrl-y 
            or Alt-y.

History:
Ctrl-p : move up through the history list
Ctrl-n : move down through the history list
Alt-<  : move to first line in history
Alt->  : move to last line in history


▒█▀▀█ ░█▀▀█ ▒█▀▀▀█ ▒█░▒█ 
▒█▀▀▄ ▒█▄▄█ ░▀▀▀▄▄ ▒█▀▀█ 
▒█▄▄█ ▒█░▒█ ▒█▄▄▄█ ▒█░▒█ 

< https://www.gnu.org/software/bash/manual/bash.html >

> builtin: A command that is implemented internally by the shell itself, rather 
            than by an executable program somewhere in the file system.

> control operator: A token that performs a control function. It is a newline or 
            one of the following: ‘||’, ‘&&’, ‘&’, ‘;’, ‘;;’, ‘;&’, ‘;;&’, ‘|’, 
            ‘|&’, ‘(’, or ‘)’.

> metacharacter: A character that, when unquoted, separates words. A metacharacter 
            is a space, tab, newline, or one of the following characters: ‘|’, ‘&’, 
            ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’.

> token: A sequence of characters considered a single unit by the shell. It is either
            a word or an operator.

> word: A sequence of characters treated as a unit by the shell. Words may not include 
            unquoted metacharacters.




▒█▀▀█ ░█▀▀█ ▒█▀▀█ ▒█▀▀▀█ ▒█▀▀▀ ▒█▀▀█ 
▒█▄▄█ ▒█▄▄█ ▒█▄▄▀ ░▀▀▀▄▄ ▒█▀▀▀ ▒█▄▄▀ 
▒█░░░ ▒█░▒█ ▒█░▒█ ▒█▄▄▄█ ▒█▄▄▄ ▒█░▒█ 

Different input to be parsed:
-> ' '		Single quotes
-> " "		Double Quotes
-> <		Redirect input
-> >		Redirect output
-> <<		Should be given a delimiter, then read the input
		until a line containing the delimiter is seen.
-> |		Send output of one command to another
-> $ 		(Environment variables)
-> $?


A metacharacter is a space, tab, newline, or one of the following characters:
‘|’, ‘&’, ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’.


Order in which to make the list of arguments:

1. Create the [loop].

2. Define [start] at the position of the word found.

3. Iterate through the [buffer] in order to find the end of the word.

4. Once found, add a node to the back of a linked list, sending the word
    through the [substr] function.

5. Give a [type value] to the node (?), so the next executions know what they are 
    doing.
    Example:
        -> When calling "$NAME" it's getting registered as that but in the function it will
            get expanded to it's value.










// Returns the inode number of a file descriptor
int get_inode(int fd)
{
    struct stat buf;
    int ret;

    ret = fstat(fd, &buf);
    if (ret < 0)
    {
        perror("fstat");
        return (-1);
    }
    return (buf.st_ino);
}

