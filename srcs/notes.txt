https://www.megaemoji.com/generators/tarty/

https://manytools.org/hacker-tools/ascii-banner/ -> ansi shadow

https://linuxcommandlibrary.com/man/toilet -> nice thing


Try 



▒█▀▄▀█ ▀█▀ ▒█▄░▒█ ▀█▀ ▒█▀▀▀█ ▒█░▒█ ▒█▀▀▀ ▒█░░░ ▒█░░░ 
▒█▒█▒█ ▒█░ ▒█▒█▒█ ▒█░ ░▀▀▀▄▄ ▒█▀▀█ ▒█▀▀▀ ▒█░░░ ▒█░░░ 
▒█░░▒█ ▄█▄ ▒█░░▀█ ▄█▄ ▒█▄▄▄█ ▒█░▒█ ▒█▄▄▄ ▒█▄▄█ ▒█▄▄█ 


Manual POSIX: < https://pubs.opengroup.org/onlinepubs/9699919799/ >

Tree Guide: < https://dev.to/oyagci/generating-a-parse-tree-from-a-shell-grammar-f1 >

Front-End Parser Visualizer: < https://vorpaljs.github.io/bash-parser-playground/ >

Bash Manual: < https://www.gnu.org/software/bash/manual/bash.html >

Readline Manual: < https://tiswww.case.edu/php/chet/readline/readline.html#Programming-with-GNU-Readline >

"Guide to write your own shell": < https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf >

Boa documentação: < https://github.com/madebypixel02/minishell >


Tasks actuais:

> Tratar do texto na expansão das variávies.




hello

▒█▀▀█ ▒█▀▀▀ ░█▀▀█ ▒█▀▀▄ ▒█░░░ ▀█▀ ▒█▄░▒█ ▒█▀▀▀ 
▒█▄▄▀ ▒█▀▀▀ ▒█▄▄█ ▒█░▒█ ▒█░░░ ▒█░ ▒█▒█▒█ ▒█▀▀▀ 
▒█░▒█ ▒█▄▄▄ ▒█░▒█ ▒█▄▄▀ ▒█▄▄█ ▄█▄ ▒█░░▀█ ▒█▄▄▄ 

(Estas são apenas algumas das mais importantes da biblioteca.)

< https://tiswww.case.edu/php/chet/readline/readline.html#Programming-with-GNU-Readline >

Notice how C-f moves forward a character,
while M-f moves forward a word. It is a loose 
convention that control keystrokes operate on 
characters while meta keystrokes operate on words.

Movement commands:
Ctrl-a : move back to start of line
Ctrl-b : move back one character 
Alt-b  : move back a word
Ctrl-e : move forward to end of line
Ctrl-f : move forward one character
Alt-f  : move forward a word

Deletion:
Ctrl-l : clear screen and print current line at top
Ctrl-d : erase current character 
Ctrl-h : erase back one character
Alt-r  : erase current line

Kill and Yank:
Ctrl-k : kill the text from the current position
            the end of the line
Alt-d  : kill from cursor to the end of current word,
            or if between words, to the end of the next
            word
Ctrl-w : kill from the cursor to the previous whitespace
Ctrl-y : yank the most recently killed text into cursor position
Alt-y  : rotate kill-ring, and yank the new top. only
            possible if previous command was Ctrl-y 
            or Alt-y.

History:
Ctrl-p : move up through the history list
Ctrl-n : move down through the history list
Alt-<  : move to first line in history
Alt->  : move to last line in history


▒█▀▀█ ░█▀▀█ ▒█▀▀▀█ ▒█░▒█ 
▒█▀▀▄ ▒█▄▄█ ░▀▀▀▄▄ ▒█▀▀█ 
▒█▄▄█ ▒█░▒█ ▒█▄▄▄█ ▒█░▒█ 

< https://www.gnu.org/software/bash/manual/bash.html >

> builtin: A command that is implemented internally by the shell itself, rather 
            than by an executable program somewhere in the file system.

> control operator: A token that performs a control function. It is a newline or 
            one of the following: ‘||’, ‘&&’, ‘&’, ‘;’, ‘;;’, ‘;&’, ‘;;&’, ‘|’, 
            ‘|&’, ‘(’, or ‘)’.

> metacharacter: A character that, when unquoted, separates words. A metacharacter 
            is a space, tab, newline, or one of the following characters: ‘|’, ‘&’, 
            ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’.

> token: A sequence of characters considered a single unit by the shell. It is either
            a word or an operator.

> word: A sequence of characters treated as a unit by the shell. Words may not include 
            unquoted metacharacters.


!!!!! IMPORTANTE !!!!!

3.1.1 Shell Operation
The following is a brief description of the shell’s operation when it reads and 
    executes a command. 

Basically, the shell does the following:
> Reads its input from a file (Shell Scripts), from a string supplied as an argument
    to the -c invocation option (see Invoking Bash), or from the user’s terminal.

> Breaks the input into words and operators, obeying the quoting rules described in 
    Quoting. These tokens are separated by metacharacters. Alias expansion is performed 
    by this step (see Aliases).

> Parses the tokens into simple and compound commands (see Shell Commands).

> Performs the various shell expansions (see Shell Expansions), breaking the expanded 
    tokens into lists of filenames (see Filename Expansion) and commands and arguments.

> Performs any necessary redirections (see Redirections) and removes the redirection 
    operators and their operands from the argument list.

> Executes the command (see Executing Commands).

> Optionally waits for the command to complete and collects its exit status (see Exit Status).

                                                                                                   
██╗     ███████╗██╗  ██╗███████╗██████╗ 
██║     ██╔════╝╚██╗██╔╝██╔════╝██╔══██╗
██║     █████╗   ╚███╔╝ █████╗  ██████╔╝
██║     ██╔══╝   ██╔██╗ ██╔══╝  ██╔══██╗
███████╗███████╗██╔╝ ██╗███████╗██║  ██║
╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝


3.1.2.2 Single Quotes:
    Enclosing characters in single quotes (‘'’) preserves the literal value of each 
        character within the quotes. !A single quote may not occur between single 
        quotes, even when preceded by a backslash.!

3.1.2.3 Double Quotes
    Enclosing characters in double quotes (‘"’) preserves the literal value of all 
        characters within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and, when 
        history expansion is enabled, ‘!’. When the shell is in POSIX mode (see Bash 
        POSIX Mode), the ‘!’ has no special meaning within double quotes, even when 
        history expansion is enabled. The characters ‘$’ and ‘`’ retain their special 
        meaning within double quotes (see Shell Expansions). The backslash retains its
        special meaning only when followed by one of the following characters: ‘$’, ‘`’,
        ‘"’, ‘\’, or newline. Within double quotes, backslashes that are followed by one
        of these characters are removed. Backslashes preceding characters without a special
        meaning are left unmodified. A double quote may be quoted within double quotes by 
        preceding it with a backslash. If enabled, history expansion will be performed unless 
        an ‘!’ appearing in double quotes is escaped using a backslash. The backslash 
        preceding the ‘!’ is not removed.

    The special parameters ‘*’ and ‘@’ have special meaning when in double quotes (see
        Shell Parameter Expansion).

                                                                           
                                                                                                   
Different input to be parsed:
-> ' '		Single quotes
-> " "		Double Quotes
-> <		Redirect input
-> >		Redirect output
-> <<		Should be given a delimiter, then read the input
		until a line containing the delimiter is seen.
-> |		Send output of one command to another
-> $ 		(Environment variables)
-> $?


A metacharacter is a space, tab, newline, or one of the following characters:
‘|’, ‘&’, ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’.




███████╗██╗  ██╗██████╗  █████╗ ███╗   ██╗██████╗ ███████╗██████╗ 
██╔════╝╚██╗██╔╝██╔══██╗██╔══██╗████╗  ██║██╔══██╗██╔════╝██╔══██╗
█████╗   ╚███╔╝ ██████╔╝███████║██╔██╗ ██║██║  ██║█████╗  ██████╔╝
██╔══╝   ██╔██╗ ██╔═══╝ ██╔══██║██║╚██╗██║██║  ██║██╔══╝  ██╔══██╗
███████╗██╔╝ ██╗██║     ██║  ██║██║ ╚████║██████╔╝███████╗██║  ██║
╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝
                                                                  






















// Returns the inode number of a file descriptor
int get_inode(int fd)
{
    struct stat buf;
    int ret;

    ret = fstat(fd, &buf);
    if (ret < 0)
    {
        perror("fstat");
        return (-1);
    }
    return (buf.st_ino);
}
