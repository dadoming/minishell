Manual POSIX:
https://pubs.opengroup.org/onlinepubs/9699919799/

https://dev.to/oyagci/generating-a-parse-tree-from-a-shell-grammar-f1

parser:
https://vorpaljs.github.io/bash-parser-playground/

||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||                                                      ||
||  https://www.gnu.org/software/bash/manual/bash.html  ||
||                                                      ||
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Resumo da Readline library:

https://tiswww.case.edu/php/chet/readline/readline.html#Programming-with-GNU-Readline

Notice how C-f moves forward a character,
while M-f moves forward a word. It is a loose 
convention that control keystrokes operate on 
characters while meta keystrokes operate on words.

Movement commands:
Ctrl-a : move back to start of line
Ctrl-b : move back one character 
Alt-b  : move back a word
Ctrl-e : move forward to end of line
Ctrl-f : move forward one character
Alt-f  : move forward a word

Deletion:
Ctrl-l : clear screen and print current line at top
Ctrl-d : erase current character 
Ctrl-h : erase back one character
Alt-r  : erase current line

Kill and Yank:
Ctrl-k : kill the text from the current position
            the end of the line
Alt-d  : kill from cursor to the end of current word,
            or if between words, to the end of the next
            word
Ctrl-w : kill from the cursor to the previous whitespace
Ctrl-y : yank the most recently killed text into cursor position
Alt-y  : rotate kill-ring, and yank the new top. only
            possible if previous command was Ctrl-y 
            or Alt-y.

History:
Ctrl-p : move up through the history list
Ctrl-n : move down through the history list
Alt-<  : move to first line in history
Alt->  : move to last line in history


|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
||                                                     ||  
||   ||||||| ||||||| ||||||| ||||||| ||||||| |||||||   ||
||   ||   || ||   || ||   || |||     ||      ||   ||   ||
||   ||||||| ||||||| |||||||   |||   |||||   |||||||   || 
||   ||      ||   || ||  ||      ||| ||      ||  ||    ||
||   ||      ||   || ||   || ||||||| ||||||| ||   ||   ||
||                                                     ||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||


Order in which to make the list of arguments:

1. Create the [loop].

2. Define [start] at the position of the word found.

3. Iterate through the [buffer] in order to find the end of the word.

4. Once found, add a node to the back of a linked list, sending the word
    through the [substr] function.

5. Give a [type value] to the node (?), so the next executions know what they are 
    doing.
    Example:
        -> When calling "$NAME" it's getting registered as that but in the function it will
            get expanded to it's value.










// Returns the inode number of a file descriptor
int get_inode(int fd)
{
    struct stat buf;
    int ret;

    ret = fstat(fd, &buf);
    if (ret < 0)
    {
        perror("fstat");
        return (-1);
    }
    return (buf.st_ino);
}

